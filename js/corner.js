/*!
 * jQuery corner plugin: simple corner rounding
 * Examples and documentation at: http://jquery.malsup.com/corner/
 * version 2.12 (23-MAY-2011)
 * Requires jQuery v1.3.2 or later
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Authors: Dave Methvin and Mike Alsup
 */

/**
 *  corner() takes a single string argument:  $('#myDiv').corner("effect corners width")
 *
 *  effect:  name of the effect to apply, such as round, bevel, notch, bite, etc (default is round). 
 *  corners: one or more of: top, bottom, tr, tl, br, or bl.  (default is all corners)
 *  width:   width of the effect; in the case of rounded corners this is the radius. 
 *           specify this value using the px suffix such as 10px (yes, it must be pixels).
 */
(function (a) { var d = document.createElement("div").style, c = d.MozBorderRadius !== undefined, e = d.WebkitBorderRadius !== undefined, b = d.borderRadius !== undefined || d.BorderRadius !== undefined, h = document.documentMode || 0, j = a.browser.msie && (a.browser.version < 8 && !h || h < 8), g = a.browser.msie && function () { var a = document.createElement("div"); try { a.style.setExpression("width", "0+0"); a.style.removeExpression("width") } catch (b) { return false } return true } (); a.support = a.support || {}; a.support.borderRadius = c || e || b; function i(b, c) { return parseInt(a.css(b, c)) || 0 } function f(a) { a = parseInt(a).toString(16); return a.length < 2 ? "0" + a : a } function l(c) { while (c) { var b = a.css(c, "backgroundColor"), d; if (b && b != "transparent" && b != "rgba(0, 0, 0, 0)") { if (b.indexOf("rgb") >= 0) { d = b.match(/\d+/g); return "#" + f(d[0]) + f(d[1]) + f(d[2]) } return b } if (c.nodeName.toLowerCase() == "html") break; c = c.parentNode } return "#ffffff" } function k(c, b, a) { switch (c) { case "round": return Math.round(a * (1 - Math.cos(Math.asin(b / a)))); case "cool": return Math.round(a * (1 + Math.cos(Math.asin(b / a)))); case "sharp": return a - b; case "bite": return Math.round(a * Math.cos(Math.asin((a - b - 1) / a))); case "slide": return Math.round(a * Math.atan2(b, a / b)); case "jut": return Math.round(a * Math.atan2(a, a - b - 1)); case "curl": return Math.round(a * Math.atan(b)); case "tear": return Math.round(a * Math.cos(b)); case "wicked": return Math.round(a * Math.tan(b)); case "long": return Math.round(a * Math.sqrt(b)); case "sculpt": return Math.round(a * Math.log(a - b - 1, a)); case "dogfold": case "dog": return b & 1 ? b + 1 : a; case "dog2": return b & 2 ? b + 1 : a; case "dog3": return b & 3 ? b + 1 : a; case "fray": return b % 2 * a; case "notch": return a; case "bevelfold": case "bevel": return b + 1; case "steep": return b / 2 + 1; case "invsteep": return (a - b) / 2 + 1 } } a.fn.corner = function (d) { if (this.length == 0) { if (!a.isReady && this.selector) { var h = this.selector, f = this.context; a(function () { a(h, f).corner(d) }) } return this } return this.each(function () { var v = a(this), p = [v.attr(a.fn.corner.defaults.metaAttr) || "", d || ""].join(" ").toLowerCase(), I = /keep/.test(p), E = (p.match(/cc:(#[0-9a-f]+)/) || [])[1], G = (p.match(/sc:(#[0-9a-f]+)/) || [])[1], m = parseInt((p.match(/(\d+)px/) || [])[1]) || 10, J = /round|bevelfold|bevel|notch|bite|cool|sharp|slide|jut|curl|tear|fray|wicked|sculpt|long|dog3|dog2|dogfold|dog|invsteep|steep/, F = (p.match(J) || ["round"])[0], H = /dogfold|bevelfold/.test(p), C = { T: 0, B: 1 }, f = { TL: /top|tl|left/.test(p), TR: /top|tr|right/.test(p), BL: /bottom|bl|left/.test(p), BR: /bottom|br|right/.test(p) }, t, q, B, u, n, o, h, D, y, A, x, r, z, s; if (!f.TL && !f.TR && !f.BL && !f.BR) f = { TL: 1, TR: 1, BL: 1, BR: 1 }; if (a.fn.corner.defaults.useNative && F == "round" && (b || c || e) && !E && !G) { f.TL && v.css(b ? "border-top-left-radius" : c ? "-moz-border-radius-topleft" : "-webkit-border-top-left-radius", m + "px"); f.TR && v.css(b ? "border-top-right-radius" : c ? "-moz-border-radius-topright" : "-webkit-border-top-right-radius", m + "px"); f.BL && v.css(b ? "border-bottom-left-radius" : c ? "-moz-border-radius-bottomleft" : "-webkit-border-bottom-left-radius", m + "px"); f.BR && v.css(b ? "border-bottom-right-radius" : c ? "-moz-border-radius-bottomright" : "-webkit-border-bottom-right-radius", m + "px"); return } t = document.createElement("div"); a(t).css({ overflow: "hidden", height: "1px", minHeight: "1px", fontSize: "1px", backgroundColor: G || "transparent", borderStyle: "solid" }); q = { T: parseInt(a.css(this, "paddingTop")) || 0, R: parseInt(a.css(this, "paddingRight")) || 0, B: parseInt(a.css(this, "paddingBottom")) || 0, L: parseInt(a.css(this, "paddingLeft")) || 0 }; if (typeof this.style.zoom != undefined) this.style.zoom = 1; if (!I) this.style.border = "none"; t.style.borderColor = E || l(this.parentNode); B = a(this).outerHeight(); for (u in C) { n = C[u]; if (n && (f.BL || f.BR) || !n && (f.TL || f.TR)) { t.style.borderStyle = "none " + (f[u + "R"] ? "solid" : "none") + " none " + (f[u + "L"] ? "solid" : "none"); o = document.createElement("div"); a(o).addClass("jquery-corner"); h = o.style; n ? this.appendChild(o) : this.insertBefore(o, this.firstChild); if (n && B != "auto") { if (a.css(this, "position") == "static") this.style.position = "relative"; h.position = "absolute"; h.bottom = h.left = h.padding = h.margin = "0"; if (g) h.setExpression("width", "this.parentNode.offsetWidth"); else h.width = "100%" } else if (!n && a.browser.msie) { if (a.css(this, "position") == "static") this.style.position = "relative"; h.position = "absolute"; h.top = h.left = h.right = h.padding = h.margin = "0"; if (g) { D = i(this, "borderLeftWidth") + i(this, "borderRightWidth"); h.setExpression("width", "this.parentNode.offsetWidth - " + D + '+ "px"') } else h.width = "100%" } else { h.position = "relative"; h.margin = !n ? "-" + q.T + "px -" + q.R + "px " + (q.T - m) + "px -" + q.L + "px" : q.B - m + "px -" + q.R + "px -" + q.B + "px -" + q.L + "px" } for (y = 0; y < m; y++) { A = Math.max(0, k(F, y, m)); x = t.cloneNode(false); x.style.borderWidth = "0 " + (f[u + "R"] ? A : 0) + "px 0 " + (f[u + "L"] ? A : 0) + "px"; n ? o.appendChild(x) : o.insertBefore(x, o.firstChild) } if (H && a.support.boxModel) { if (n && j) continue; for (r in f) { if (!f[r]) continue; if (n && (r == "TL" || r == "TR")) continue; if (!n && (r == "BL" || r == "BR")) continue; z = { position: "absolute", border: "none", margin: 0, padding: 0, overflow: "hidden", backgroundColor: t.style.borderColor }; s = a("<div/>").css(z).css({ width: m + "px", height: "1px" }); switch (r) { case "TL": s.css({ bottom: 0, left: 0 }); break; case "TR": s.css({ bottom: 0, right: 0 }); break; case "BL": s.css({ top: 0, left: 0 }); break; case "BR": s.css({ top: 0, right: 0 }) } o.appendChild(s[0]); var w = a("<div/>").css(z).css({ top: 0, bottom: 0, width: "1px", height: m + "px" }); switch (r) { case "TL": w.css({ left: m }); break; case "TR": w.css({ right: m }); break; case "BL": w.css({ left: m }); break; case "BR": w.css({ right: m }) } o.appendChild(w[0]) } } } } }) }; a.fn.uncorner = function () { (b || c || e) && this.css(b ? "border-radius" : c ? "-moz-border-radius" : "-webkit-border-radius", 0); a("div.jquery-corner", this).remove(); return this }; a.fn.corner.defaults = { useNative: true, metaAttr: "data-corner"} })(jQuery)